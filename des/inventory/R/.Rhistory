    result[i,] <- result[i,] +
        c(inv.sys$total_ordering_cost,
          inv.sys$holding_cost*inv.sys$area_holding,
          inv.sys$shortage_cost*inv.sys$area_shortage) 
  }
}
result <- result/(inv.sys$num_months*nruns)
result
setwd("~/solutions/des/inventory/R")
source("utils.R")
source("conf-1.R")
nruns   <- 1L
inv.sys <- new.env()
input.conf(inv.sys)
result  <- matrix(0.0, nrow = inv.sys$num_policies, ncol = 3)
for (irun in seq(nruns)) {
  for (i in seq(inv.sys$num_policies)) {
    init.env(inv.sys)
    while (1) {
      # Determine the next event
      timing(inv.sys)
      # Update statistical counters
      update_stats(inv.sys)
      # Invoke the appropriate event routine
      j <- inv.sys$next_event_type
      switch (j,
        order_arrival(inv.sys),
        demand(inv.sys),
        break,
        evaluate(inv.sys, i=i)
      )
    }
    ofs <- (irun-1)*inv.sys$num_policies
    result[ofs+i,] <- result[ofs+i,] +
        c(inv.sys$total_ordering_cost,
          inv.sys$holding_cost*inv.sys$area_holding,
          inv.sys$shortage_cost*inv.sys$area_shortage) 
  }
}
result <- result / (inv.sys$num_months*nruns)
result
setwd("~/solutions/des/inventory/R")
source("utils.R")
source("conf-1.R")
nruns   <- 100L
inv.sys <- new.env()
input.conf(inv.sys)
result  <- matrix(0.0, nrow = inv.sys$num_policies, ncol = 3)
for (irun in seq(nruns)) {
  for (i in seq(inv.sys$num_policies)) {
    init.env(inv.sys)
    while (1) {
      # Determine the next event
      timing(inv.sys)
      # Update statistical counters
      update_stats(inv.sys)
      # Invoke the appropriate event routine
      j <- inv.sys$next_event_type
      switch (j,
        order_arrival(inv.sys),
        demand(inv.sys),
        break,
        evaluate(inv.sys, i=i)
      )
    }
    ofs <- (irun-1)*inv.sys$num_policies
    result[ofs+i,] <- result[ofs+i,] +
        c(inv.sys$total_ordering_cost,
          inv.sys$holding_cost*inv.sys$area_holding,
          inv.sys$shortage_cost*inv.sys$area_shortage) 
  }
}
setwd("~/solutions/des/inventory/R")
source("utils.R")
source("conf-1.R")
nruns   <- 100L
inv.sys <- new.env()
input.conf(inv.sys)
result  <- matrix(0.0, nrow = inv.sys$num_policies, ncol = 3)
for (irun in seq(nruns)) {
  for (i in seq(inv.sys$num_policies)) {
    init.env(inv.sys)
    while (1) {
      # Determine the next event
      timing(inv.sys)
      # Update statistical counters
      update_stats(inv.sys)
      # Invoke the appropriate event routine
      j <- inv.sys$next_event_type
      switch (j,
        order_arrival(inv.sys),
        demand(inv.sys),
        break,
        evaluate(inv.sys, i=i)
      )
    }
    result[i,] <- result[i,] +
        c(inv.sys$total_ordering_cost,
          inv.sys$holding_cost*inv.sys$area_holding,
          inv.sys$shortage_cost*inv.sys$area_shortage) 
  }
}
result <- result / (inv.sys$num_months*nruns)
result
setwd("~/solutions/des/inventory/R")
source("utils.R")
# Choose configuration
source("conf-1.R")
## Inventory system
nruns   <- 1L
inv.sys <- new.env()
input.conf(inv.sys)
result  <- matrix(0.0, nrow = inv.sys$num_policies, ncol = 3)
# Policy (s,S) or (small_s,big_s) index
for (irun in seq(nruns)) {
  for (i in seq(inv.sys$num_policies)) {
    init.env(inv.sys)
    while (1) {
      # Determine the next event
      timing(inv.sys)
      # Update statistical counters
      update_stats(inv.sys)
      # Invoke the appropriate event routine
      j <- inv.sys$next_event_type
      switch (j,
        order_arrival(inv.sys),
        demand(inv.sys),
        break,
        evaluate(inv.sys, i=i)
      )
    }
    result[i,] <- result[i,] +
        c(inv.sys$total_ordering_cost,
          inv.sys$holding_cost*inv.sys$area_holding,
          inv.sys$shortage_cost*inv.sys$area_shortage) 
  }
}
  for (i in seq(inv.sys$num_policies)) {
    init.env(inv.sys)
    while (1) {
      # Determine the next event
      timing(inv.sys)
      # Update statistical counters
      update_stats(inv.sys)
      # Invoke the appropriate event routine
      j <- inv.sys$next_event_type
      switch (j,
                                                                                                                                  ] <- result[i,] +
        c(inv.sys$total_ordering_cost,
          inv.sys$holding_cost*inv.sys$area_holding,
          inv.sys$shortage_cost*inv.sys$area_shortage) 
  }
                            il              # Determine the next event
      timing(inv.sys)
      # Update st      # Update ers
      update_stats(inv.sys)
      # Invoke the appropri      # Invokti      # Invoke the appropri  ent_type
      s      s      s      s      s al(inv.sys),
        demand(inv.sys),
        break,
        evaluate(inv.sys, i=i)
      )
    }
      # Determine the next event
      timing(inv.sys)
                                          up                              voke the                                                     en                                  de                                                                      ulu                                  order_arrival(inv.                                          up                              voke the                                                     en         or                                     g_                                          up       ge                                          up          or  ri                                          up                                               st                                   i                          s$                                          up                              vokesu                                          up   ot                       st), type='l')
# # # # # # # # # # # # # # # #t))
setwd("~/solutions/des/inventory/R")
source("utils.R")
source("conf-1.R")
nruns   <- 1L
inv.sys <- new.env()
input.conf(inv.sys)
result  <- matrix(0.0, nrow = inv.sys$num_policies, ncol = 3)
for (irun in seq(nruns)) {
  for (i in seq(inv.sys$num_policies)) {
    init.env(inv.sys)
    while (1) {
      # Determine the next event
      timing(inv.sys)
      # Update statistical counters
      update_stats(inv.sys)
      # Invoke the appropriate event routine
      j <- inv.sys$next_event_type
      switch (j,
        order_arrival(inv.sys),
        demand(inv.sys),
        break,
        evaluate(inv.sys, i=i)
      )
    }
    result[i,] <- result[i,] +
        c(inv.sys$total_ordering_cost,
          inv.sys$holding_cost*inv.sys$area_holding,
          inv.sys$shortage_cost*inv.sys$area_shortage) 
  }
}
result <- result / (inv.sys$num_months*nruns)
result
setwd("~/solutions/des/inventory/R")
source("utils.R")
source("conf-1.R")
nruns   <- 1L
inv.sys <- new.env()
input.conf(inv.sys)
result  <- matrix(0.0, nrow = inv.sys$num_policies, ncol = 3)
for (irun in seq(nruns)) {
  for (i in seq(inv.sys$num_policies)) {
    init.env(inv.sys)
    while (1) {
      # Determine the next event
      timing(inv.sys)
      # Update statistical counters
      update_stats(inv.sys)
      # Invoke the appropriate event routine
      j <- inv.sys$next_event_type
      switch (j,
        order_arrival(inv.sys),
        demand(inv.sys),
        break,
        evaluate(inv.sys, i=i)
      )
    }
    result[i,] <- result[i,] +
        c(inv.sys$total_ordering_cost,
          inv.sys$holding_cost*inv.sys$area_holding,
          inv.sys$shortage_cost*inv.sys$area_shortage) 
  }
}
result <- result / (inv.sys$num_months*nruns)
result
setwd("~/solutions/des/inventory/R")
source("utils.R")
source("conf-1.R")
nruns   <- 100L
inv.sys <- new.env()
input.conf(inv.sys)
result  <- matrix(0.0, nrow = inv.sys$num_policies, ncol = 3)
for (irun in seq(nruns)) {
  for (i in seq(inv.sys$num_policies)) {
    init.env(inv.sys)
    while (1) {
      # Determine the next event
      timing(inv.sys)
      # Update statistical counters
      update_stats(inv.sys)
      # Invoke the appropriate event routine
      j <- inv.sys$next_event_type
      switch (j,
        order_arrival(inv.sys),
        demand(inv.sys),
        break,
        evaluate(inv.sys, i=i)
      )
    }
    result[i,] <- result[i,] +
        c(inv.sys$total_ordering_cost,
          inv.sys$holding_cost*inv.sys$area_holding,
          inv.sys$shortage_cost*inv.sys$area_shortage) 
  }
}
result <- result / (inv.sys$num_months*nruns)
t(t(rowSums(result)))
setwd("~/solutions/des/inventory/R")
source("utils.R")
source("conf-1.R")
nruns   <- 100L
inv.sys <- new.env()
input.conf(inv.sys)
result  <- matrix(0.0, nrow = nruns*inv.sys$num_policies, ncol = 3)
for (irun in seq(nruns)) {
  for (i in seq(inv.sys$num_policies)) {
    init.env(inv.sys)
    while (1) {
      # Determine the next event
      timing(inv.sys)
      # Update statistical counters
      update_stats(inv.sys)
      # Invoke the appropriate event routine
      j <- inv.sys$next_event_type
      switch (j,
        order_arrival(inv.sys),
        demand(inv.sys),
        break,
        evaluate(inv.sys, i=i)
      )
    }
    idx <- (nruns-1)*inv.sys$num_policies + i
    result[idx,] <- result[idx,] +
        c(inv.sys$total_ordering_cost,
          inv.sys$holding_cost*inv.sys$area_holding,
          inv.sys$shortage_cost*inv.sys$area_shortage) 
  }
    result[idx,] <- result[idx,] / env$num_months
}
setwd("~/solutions/des/inventory/R")
source("utils.R")
source("conf-1.R")
nruns   <- 100L
inv.sys <- new.env()
input.conf(inv.sys)
result  <- matrix(0.0, nrow = nruns*inv.sys$num_policies, ncol = 3)
for (irun in seq(nruns)) {
  for (i in seq(inv.sys$num_policies)) {
    init.env(inv.sys)
    while (1) {
      # Determine the next event
      timing(inv.sys)
      # Update statistical counters
      update_stats(inv.sys)
      # Invoke the appropriate event routine
      j <- inv.sys$next_event_type
      switch (j,
        order_arrival(inv.sys),
        demand(inv.sys),
        break,
        evaluate(inv.sys, i=i)
      )
    }
    idx <- (nruns-1)*inv.sys$num_policies + i
    result[idx,] <- result[idx,] +
        c(inv.sys$total_ordering_cost,
          inv.sys$holding_cost*inv.sys$area_holding,
          inv.sys$shortage_cost*inv.sys$area_shortage) 
  }
    result[idx,] <- result[idx,] / inv.sys$num_months
}
result
setwd("~/solutions/des/inventory/R")
source("utils.R")
source("conf-1.R")
nruns   <- 100L
inv.sys <- new.env()
input.conf(inv.sys)
result  <- matrix(0.0, nrow = nruns*inv.sys$num_policies, ncol = 3)
for (irun in seq(nruns)) {
  for (i in seq(inv.sys$num_policies)) {
    init.env(inv.sys)
    while (1) {
      # Determine the next event
      timing(inv.sys)
      # Update statistical counters
      update_stats(inv.sys)
      # Invoke the appropriate event routine
      j <- inv.sys$next_event_type
      switch (j,
        order_arrival(inv.sys),
        demand(inv.sys),
        break,
        evaluate(inv.sys, i=i)
      )
    }
    idx <- (irun-1)*inv.sys$num_policies + i
    result[idx,] <- result[idx,] +
        c(inv.sys$total_ordering_cost,
          inv.sys$holding_cost*inv.sys$area_holding,
          inv.sys$shortage_cost*inv.sys$area_shortage) 
  }
    result[idx,] <- result[idx,] / inv.sys$num_months
}
result
setwd("~/solutions/des/inventory/R")
source("utils.R")
source("conf-1.R")
nruns   <- 100L
inv.sys <- new.env()
input.conf(inv.sys)
result  <- matrix(0.0, nrow = nruns*inv.sys$num_policies, ncol = 3)
for (irun in seq(nruns)) {
  for (i in seq(inv.sys$num_policies)) {
    init.env(inv.sys)
    while (1) {
      # Determine the next event
      timing(inv.sys)
      # Update statistical counters
      update_stats(inv.sys)
      # Invoke the appropriate event routine
      j <- inv.sys$next_event_type
      switch (j,
        order_arrival(inv.sys),
        demand(inv.sys),
        break,
        evaluate(inv.sys, i=i)
      )
    }
    idx <- (irun-1)*inv.sys$num_policies + i
    result[idx,] <- c(inv.sys$total_ordering_cost,
                      inv.sys$holding_cost*inv.sys$area_holding,
                      inv.sys$shortage_cost*inv.sys$area_shortage) / inv.sys$num_months 
  }
}
result
seq(1:9)
rep(seq(9),2)
matrix(rep(seq(9),2), ncol=2)
matrix(rep(seq(9),2), nrow=2)
matrix(rep(seq(9),2), ncol=2)
t(matrix(rep(seq(9),2), ncol=2))
c(t(matrix(rep(seq(9),2), ncol=2)))
rep(seq(9), each=9)
data.table(idx=rep(seq(m),each=m),result)
data.table::data.table(idx=rep(seq(m),each=m),result)
m <- inv.sys$num_policies
data.table::data.table(idx=rep(seq(m),each=m),result)
m <- inv.sys$num_policies
data.table::data.table(
    idx=rep(seq(m),each=m),
    (avg_ordering_cost,avg_holding_cost,avg_shortage_cost):=result)
data.table::data.table(
    idx=rep(seq(m),each=m),
    (avg_ordering_cost,avg_holding_cost,avg_shortage_cost)=result)
data.table::data.table(
    idx=rep(seq(m),each=m),
    c("avg_ordering_cost","avg_holding_cost","avg_shortage_cost")=result)
    idx=rep(seq(m),each=m),result)
data.table::data.table(idx=rep(seq(m),each=m),result)
data.table::data.table(idx=rep(seq(m),each=m),result)
data.table::data.table(idx=rep(seq(m),nruns),result)
data.table::data.table(idx=rep(seq(m),nruns),result)[.sum(V1,V2,V3),idx]
data.table::data.table(idx=rep(seq(m),nruns),result)[.(sum(V1,V2,V3)),idx]
data.table::data.table(idx=rep(seq(m),nruns),result)[,.(sum(V1,V2,V3)),idx]
data.table::data.table(idx=rep(seq(m),nruns),result)[,.(mean(V1,V2,V3)),idx]
data.table::data.table(idx=rep(seq(m),nruns),result)[,.(sum(V1,V2,V3)),idx]
data.table::data.table(idx=rep(seq(m),nruns),result)[,.(mean(V1,V2,V3)),idx]
data.table::data.table(idx=rep(seq(m),nruns),result)[,lapply(.SD,mean),idx]
setwd("~/solutions/des/inventory/R")
source("utils.R")
source("conf-1.R")
nruns   <- 100L
inv.sys <- new.env()
input.conf(inv.sys)
result  <- matrix(0.0, nrow = nruns*inv.sys$num_policies, ncol = 3)
for (irun in seq(nruns)) {
  for (i in seq(inv.sys$num_policies)) {
    init.env(inv.sys)
    while (1) {
      # Determine the next event
      timing(inv.sys)
      # Update statistical counters
      update_stats(inv.sys)
      # Invoke the appropriate event routine
      j <- inv.sys$next_event_type
      switch (j,
        order_arrival(inv.sys),
        demand(inv.sys),
        break,
        evaluate(inv.sys, i=i)
      )
    }
    idx <- (irun-1)*inv.sys$num_policies + i
    result[idx,] <- c(inv.sys$total_ordering_cost,
                      inv.sys$holding_cost*inv.sys$area_holding,
                      inv.sys$shortage_cost*inv.sys$area_shortage) / inv.sys$num_months 
  }
}
m <- inv.sys$num_policies
data.table::data.table(idx=rep(seq(m),nruns),result)[,lapply(.SD,mean),idx]
DT[,.(sum(V1,V2,V3))]
DT <- data.table::data.table(idx=rep(seq(m),nruns),result)[,lapply(.SD,mean),idx]
DT[,.(sum(V1,V2,V3))]
DT <- data.table::data.table(idx=rep(seq(m),nruns),result)[,lapply(.SD,mean),idx]
DT <- data.table::data.table(idx=rep(seq(m),nruns),result)[,lapply(.SD,mean),idx]
DT
DT[,lapply(.SD,sum),.SDcols=c("V1","V2","V3")]
DT[,rowSums(.SD),.SDcols=c("V1","V2","V3")]
DT[,avg_total_cost:=Reduce(`+`,.SD),.SDcols=c("V1","V2","V3")]
DT
DT[,avg_total_cost=Reduce(`+`,.SD),.SDcols=c("V1","V2","V3")]
DT[,Reduce(`+`,.SD),.SDcols=c("V1","V2","V3")]
m  <- inv.sys$num_policies
DT <- data.table::data.table(idx=rep(seq(m),nruns),result)[,lapply(.SD,mean),idx]
DT[,avg_total_cost:=Reduce(`+`,.SD),.SDcols=c("V1","V2","V3")]
DT
setwd("~/solutions/des/inventory/R")
source("utils.R")
source("conf-2.R")
nruns   <- 100L
inv.sys <- new.env()
input.conf(inv.sys)
result  <- matrix(0.0, nrow = nruns*inv.sys$num_policies, ncol = 3)
for (irun in seq(nruns)) {
  for (i in seq(inv.sys$num_policies)) {
    init.env(inv.sys)
    while (1) {
      # Determine the next event
      timing(inv.sys)
      # Update statistical counters
      update_stats(inv.sys)
      # Invoke the appropriate event routine
      j <- inv.sys$next_event_type
      switch (j,
        order_arrival(inv.sys),
        demand(inv.sys),
        break,
        evaluate(inv.sys, i=i)
      )
    }
    idx <- (irun-1)*inv.sys$num_policies + i
    result[idx,] <- c(inv.sys$total_ordering_cost,
                      inv.sys$holding_cost*inv.sys$area_holding,
                      inv.sys$shortage_cost*inv.sys$area_shortage) / inv.sys$num_months 
  }
}
m  <- inv.sys$num_policies
DT <- data.table::data.table(idx=rep(seq(m),nruns),result)[,lapply(.SD,mean),idx]
DT[,avg_total_cost:=Reduce(`+`,.SD),.SDcols=c("V1","V2","V3")]
DT
expand.grid(c(0,1,2))
expand.grid(c(0,1,2),c(1,2,3))
seq(5,100,5)
expand.grid(seq(0,95,5),seq(5,100))
quit()
